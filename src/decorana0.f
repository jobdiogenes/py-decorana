C CORNELL ECOLOGY PROGRAM DECORANA - WRITTEN BY M.O. HILL, JULY 1979
C SOURCE CODE AND ACCOMPANYING DOCUMENTATION ARE AVAILABLE FROM
C HUGH G. GAUCH, JR., ECOLOGY AND SYSTEMATICS, CORNELL UNIVERSITY,
C ITHACA, NEW YORK 14850.
C
C PERFORMS DETRENDED CORRESPONDENCE ANALYSIS;  ALSO WILL DO RECIPROCAL
C AVERAGING AS A SPECIAL CASE.
C
C DIMENSIONED FOR 1000 SAMPLES, 500 SPECIES, 20000 NON-ZERO ITEMS IN
C DATA MATRIX.
C
C INPUT DEVICES ARE 3 (INPUT PARAMETERS), 5 (DATA MATRIX)
C OUTPUT DEVICES ARE 4 (CONSOLE MONITORING), 7 (COPY OF SOLUTION
C IN MACHINE-READABLE FORM), AND LINEPRINTER USING FORTRAN
C WORD PRINT.
C
C    MODIFIED FOR VAX VMS SYSTEMS BY DR P.R. MINCHIN  FEB 1988
C
C    DIMENSIONS INCREASED TO 2000 SAMPLES, 5000 SPECIES AND 130000
C      NON-ZERO ITEMS IN THE DATA MATRIX.
C
C    LOGICAL UNITS ARE STORED IN VARIABLES IN COMMON BLOCK LUNITS
C      AND USED AS FOLLOWS:
C                                OLD        NEW    VARIABLE
C    INPUT OPTIONS FILE            3          5      IUINP1
C    OUTPUT PROMPTS                4          6      IUOUT1
C    INPUT DATA MATRIX             5          1      IUINP2
C    OUTPUT LINEPRINTER            6          3      IUOUT2
C    OUTPUT CONFIGURATIONS         7          2      IUOUT3
C
C    FORMAT OF CONFIGURATION (WRITTEN TO UNIT 2) CHANGED TO (8F10.4)
C      AND OTHER ANNOTATION ETC REMOVED.
C    FIRST 4 COLS ARE SAMPLE SCORES AND LAST 4 ARE SPECIES SCORES.
C    SCORES ARE DIVIDED BY 1000 COMPARED WITH PRINTED OUTPUT.
C
C MODIFIED 6 MAY 1992 BY DR P.R. MINCHIN FOR SUN UNIX SYSTEMS:
C   SUN FORTRAN SPECIFIC CODE ADDED TO GET NAMES FOR THE FILES ON UNITS
C   IUINP2 (DATA MATRIX), IUOUT2 (PRINTED OUTPUT) AND IUOUT3 (SAMPLE
C   AND SPECIES SCORES) FROM THE COMMAND LINE, THEN OPEN THEM 
C   EXPLICITLY.  DEFAULT NAMES FOR THE PRINTOUT AND CONFIGURATION FILES
C   ARE decorana.printout AND decorana.scores RESPECTIVELY.
C
C **** Further modified by Dr Peter R. Minchin May-June 1997
C      - changed tolerance to 0.000005 and iteration limit to 999 in
C          EIGY - strict settings of Oksanen & Minchin 1997
C      - corrected the order-dependent bug in SMOOTH
C      - added PARAMETER statements for maximum dimensions
C      - changed max. dimensions to 5000, 5000, 330000
C      - updated handling of file names retrieved from command line
C      - moved character data to CHARACTER variables
C      - now accepts relaxed CCF format, with maximum number of pairs
C          per record on line 3
C See: Oksanen, J. & Minchin, P.R. 1997. Instability of ordination
C        results under changes in input data order: explanations and
C        remedies. Journal of Vegetation Science 8: 447-454.
C
C---Parameter statements added by P.Minchin May 1997
C---and constants replaced by parameters in array declarations
      PARAMETER (MAXSAM=5000, MAXSPP=5000, MAXDAT=330000)
C      PARAMETER (MAXSAM=2000, MAXSPP=5000, MAXDAT=130000)
      REAL XEIG1(MAXSAM),XEIG2(MAXSAM),XEIG3(MAXSAM),XEIG4(MAXSAM),
     .  AIDOT(MAXSAM)
C---Changed INAME to CHARACTER: P.Minchin June 1997
      INTEGER IBEGIN(MAXSAM),IEND(MAXSAM)
      CHARACTER*4 INAME1(MAXSAM),INAME2(MAXSAM)
      INTEGER IX1(MAXSAM),IX2(MAXSAM),IX3(MAXSAM),IX4(MAXSAM)
      INTEGER IXX1(MAXSAM),IXX2(MAXSAM),IXX3(MAXSAM),IXX4(MAXSAM)
      INTEGER INFLAG(MAXSAM)
      REAL Y2(MAXSPP),Y3(MAXSPP),Y4(MAXSPP),Y5(MAXSPP),V(MAXSPP)
      REAL YEIG1(MAXSPP),YEIG2(MAXSPP),YEIG3(MAXSPP),YEIG4(MAXSPP),
     .  ADOTJ(MAXSPP)
C---Changed JNAME to CHARACTER: P.Minchin June 1997
      INTEGER JNFLAG(MAXSPP)
      CHARACTER*4 JNAME1(MAXSPP),JNAME2(MAXSPP)
      INTEGER IY1(MAXSPP),IY2(MAXSPP),IY3(MAXSPP),IY4(MAXSPP)
      INTEGER IYY1(MAXSPP),IYY2(MAXSPP),IYY3(MAXSPP),IYY4(MAXSPP)
      REAL QIDAT(MAXDAT)
      INTEGER IDAT(MAXDAT)
C---Changed TITLE to CHARACTER
      REAL BEFORE(50),AFTER(50)
      CHARACTER TITLE(20)*4
C---REAL ARRAY SCORES(8) ADDED BY P.MINCHIN FEB 1988 (FOR CONFIG OUTPUT)
      REAL SCORES(8)
C---CHARACTER VARIABLES FOR FILE NAMES ADDED BY P.MINCHIN MAY 1992
      CHARACTER DATFIL*80, PRTFIL*80, OUTFIL*80
C---CHARACTER VARIABLE FOR COMMAND LINE ADDED P.Minchin June 1997
      CHARACTER CMLINE*256
      COMMON IDAT,QIDAT
C---COMMON BLOCK ADDED BY P.MINCHIN FEB 1988
      COMMON /LUNITS/ IUINP1,IUINP2,IUOUT1,IUOUT2,IUOUT3
C---Common block added by P.Minchin May 1997
      COMMON /MAXDIM/ MMAX, NMAX, IDMAX
      EQUIVALENCE (IXX1(1),XEIG1(1)),(IXX2(1),XEIG2(1))
      EQUIVALENCE (IXX3(1),XEIG3(1)),(IXX4(1),XEIG4(1))
      EQUIVALENCE (IYY1(1),YEIG1(1)),(IYY2(1),YEIG2(1))
      EQUIVALENCE (IYY3(1),YEIG3(1)),(IYY4(1),YEIG4(1))
      EQUIVALENCE (IX4(1),IBEGIN(1))
      EQUIVALENCE (IY4(1),V(1)),(JNFLAG(1),IDAT(1))
C---DIMENSIONS INCREASED BY P.MINCHIN FEB 1988
C---Max dimension variables equated to parameters: P.Minchin May 1997
C      MMAX=2000
C      NMAX=5000
C      IDMAX=130000
      MMAX=MAXSAM
      NMAX=MAXSPP
      IDMAX=MAXDAT
C---OPEN STATEMENTS COMMENTED OUT P.MINCHIN FEB 1988
C OPEN(UNIT=3,DEVICE='TTY',ACCESS='SEQIN')
C OPEN(UNIT=5,DEVICE='DSK',ACCESS='SEQIN',DIALOG)
C OPEN(UNIT=4,DEVICE='TTY',ACCESS='SEQOUT')
C OPEN(UNIT=7,DEVICE='DSK',ACCESS='SEQOUT',DIALOG)
C---ASSIGN LOGICAL UNIT NUMBERS
      IUINP1=5
      IUINP2=1
      IUOUT1=6
      IUOUT2=3
      IUOUT3=2
C
C---New program banner added P.Minchin June 1997
C
      WRITE (IUOUT1,3010)
 3010 FORMAT (/1X,'*** DECORANA: DCA and RA Ordination Program ***'//
     .  1X,'Written by Dr Mark O. Hill  July 1979'/
     .  1X,'Modified by Dr Peter R. Minchin  Feb 1988 - June 1997'//
     .  1X,'This version uses strict convergence criteria and ',
     .  'corrects the'/
     .  1X,'bug in SMOOTH - see: Oksanen & Minchin (1997) J. Veg. ',
     .  'Sci. 8: 447-454.'/)
C
C SPECIAL FILE HANDLING FOR Lahey FORTRAN 90 P.Minchin June 1997
C
C---Note: GETCL is a Lahey FORTRAN 90 intrinsic that returns the
C---contents of the command line.  IARGC and GETARG are my own
C---implementations of similar routines that are available in some
C---Unix FORTRAN compilers (e.g. Sun FORTRAN77)
C
C      CALL GETCL (CMLINE)
C      NARGS=IARGC(CMLINE)
      NARGS=IARGC()
      IF (NARGS.EQ.0) THEN
        WRITE (IUOUT1,3000)
 3000   FORMAT (/1X,'ENTER THE NAME OF THE INPUT DATA FILE'/)
        READ (IUINP1,3001) DATFIL
 3001   FORMAT (A80)
      ELSE
C        CALL GETARG (1,CMLINE,DATFIL)
        CALL GETARG (1,CMLINE)
      ENDIF
      OPEN (UNIT=IUINP2,FILE=DATFIL,STATUS='OLD')
      IF (NARGS.LT.3) THEN 
        PRTFIL='decorana.prt'
        OPEN (UNIT=IUOUT2,FILE=PRTFIL,STATUS='UNKNOWN')
      ELSE
C        CALL GETARG (3,CMLINE,PRTFIL)
        CALL GETARG (3,CMLINE)
        OPEN (UNIT=IUOUT2,FILE=PRTFIL,STATUS='NEW')
      ENDIF
      WRITE (IUOUT2,3010)
C
    5 IT=1
      AXX=0.0
      WRITE(IUOUT1,2001)
      WRITE(IUOUT2,2001)
 2001 FORMAT(1X,'ENTER TRANSFORMATION IN FREE FORMAT')
      WRITE(IUOUT1,2002)
      WRITE(IUOUT2,2002)
 2002 FORMAT(1X,'A NEGATIVE ENTRY TERMINATES TRANSFORMATION DATA',
     1/1X,'IF NO TRANSFORMATION DESIRED, MERELY TYPE -1 0'/)
   10 READ(IUINP1,*) AX,TRANSX
      WRITE(IUOUT1,2003) AX,TRANSX
      WRITE(IUOUT2,2003) AX,TRANSX
 2003 FORMAT(1X,2F8.2)
      IF(AX.LT.0.0) GOTO 20
      IF (TRANSX.LT.0.0) GOTO 20
      IF (AX.LT.AXX) GOTO 5
      IT=IT+1
      BEFORE(IT)=AX
      AFTER(IT)=TRANSX
      AXX=AX
      IF(IT.LT.46) GOTO 10
      WRITE(IUOUT1,2004)
      WRITE(IUOUT2,2004)
 2004 FORMAT(1X,'THIS IS ENOUGH - CALCULATION PROCEEDS')
   20 IF(IT.NE.1) GOTO 23
      BEFORE(2)=0.0
      AFTER(2)=0.0
      BEFORE(3)=1.0E10
      AFTER(3)=1.0E10
      IT=3
      WRITE(IUOUT2,2005)
      WRITE(IUOUT1,2005)
 2005 FORMAT(1X,'NO TRANSFORMATION OF DATA WILL BE MADE')
   23 CONTINUE
      IT=IT+1
      BEFORE(1) = 0.0
      AFTER(1)= AFTER(2)
      BEFORE(IT)=1.0E10
      AFTER(IT)=AFTER(IT-1)
      WRITE(IUOUT2,2010)
      WRITE(IUOUT1,2010)
 2010 FORMAT(1X,'IS DOWNWEIGHTING OF RARE SPECIES REQUIRED?'/
     11X,'TYPE 1 IF YES, TYPE 0 IF NO'/)
      READ(IUINP1,*) IWEIGH
      WRITE(IUOUT2,2011) IWEIGH
      WRITE(IUOUT1,2011) IWEIGH
 2011 FORMAT(1X,'ANSWER = ',I2)
      WRITE(IUOUT2,2020)
      WRITE(IUOUT1,2020)
 2020 FORMAT(1X,'IS RESCALING OF AXES REQUIRED?'/
     11X,'TYPE 0 (DEFAULT), -1 (NO RESCALING), OR NUMBER OF',
     2' TIMES TO BE DONE'/)
      READ(IUINP1,*) IRESC
      WRITE(IUOUT2,2011) IRESC
      WRITE(IUOUT1,2011) IRESC
      IF(IRESC.EQ.0) IRESC=4
      IF(IRESC.GT.20) IRESC=20
      IF(IRESC.LT.0) IRESC=0
      WRITE(IUOUT2,2030)
      WRITE(IUOUT1,2030)
 2030 FORMAT(1X,'TYPE 0 IF DETRENDED CORRESPONDENCE ANALYSIS',
     1' REQUIRED'/1X,'TYPE 1 IF BASIC RECIPROCAL AVERAGING'/)
      READ(IUINP1,*) IRA
      WRITE(IUOUT2,2011) IRA
      WRITE(IUOUT1,2011) IRA
      IF(IRA.NE.1) IRA=0
      IF(IRA.EQ.1) IRESC=0
      WRITE(IUOUT2,2035)
      WRITE(IUOUT1,2035)
 2035 FORMAT(1X,'SPECIFY NUMBER OF SEGMENTS - OR TYPE 0 FOR DEFAULT',
     1' VALUE'/)
      READ(IUINP1,*) MK
      WRITE(IUOUT2,2011) MK
      WRITE(IUOUT1,2011) MK
      IF(MK.EQ.0) MK=26
      MK=MK+4
      IF(MK.LT.14) MK=14
      IF(MK.GT.50) MK=50
      WRITE(IUOUT2,2037)
      WRITE(IUOUT1,2037)
 2037 FORMAT(1X,'SPECIFY RESCALING THRESHOLD - OR TYPE 0 FOR DEFAULT'/)
      READ(IUINP1,*) SHORT
      WRITE(IUOUT2,2003) SHORT
      WRITE(IUOUT1,2003) SHORT
C---Added logical unit: P.Minchin June 1997
      WRITE(IUOUT2,2040) IUOUT3
      WRITE(IUOUT1,2040) IUOUT3
 2040 FORMAT(1X,'SHOULD A COPY OF SOLUTION BE WRITTEN TO DEVICE ',
     1'NUMBER ',I2,'?'/1X,'TYPE 1 IF YES, TYPE 0 IF NO'/)
      READ(IUINP1,*) IPUNCH
      WRITE(IUOUT2,2011) IPUNCH
      WRITE(IUOUT1,2011) IPUNCH
C
C SPECIAL FILE HANDLING FOR Lahey FORTRAN 90 P.Minchin June 1997
C
      IF (IPUNCH.NE.0) THEN
        IF (NARGS.LT.2) THEN 
          OUTFIL='decorana.out'
          OPEN (UNIT=IUOUT3,FILE=OUTFIL,STATUS='UNKNOWN')
        ELSE
C          CALL GETARG (2,CMLINE,OUTFIL)
          CALL GETARG (2,CMLINE)
          OPEN (UNIT=IUOUT3,FILE=OUTFIL,STATUS='NEW')
        ENDIF
      ENDIF
C
      CALL QUIKIN(MMAX,NMAX,IDMAX,MI,N,INAME1,INAME2,JNAME1,JNAME2,
     1IDAT,QIDAT,IBEGIN,IEND,NID,TITLE,INFLAG)
C THIS COMPLETES THE READING IN OF THE DATA
      DO 30 ID=1,NID
      AIJ=QIDAT(ID)
      IT=0
   25 IT=IT+1
      IF(BEFORE(IT).LE.AIJ) GOTO 25
      BTOP=BEFORE(IT)
      BBOT=BEFORE(IT-1)
      ATOP=AFTER(IT)
      ABOT=AFTER(IT-1)
      AIJ=ABOT+(AIJ-BBOT)*(ATOP-ABOT)/(BTOP-BBOT)
      IF(AIJ.LT.1.0E-10) AIJ=1.0E-10
      QIDAT(ID)=AIJ
   30 CONTINUE
      DO 60 J=1,N
      YEIG1(J)=0.0
   60 Y2(J)=1.0E-10
      DO 70 I=1,MI
      ID1=IBEGIN(I)
      ID2=IEND(I)
      DO 65 ID=ID1,ID2
      J=IDAT(ID)
      AIJ=QIDAT(ID)
      YEIG1(J)=YEIG1(J)+AIJ
   65 Y2(J)=Y2(J)+AIJ*AIJ
   70 CONTINUE
      DO 80 J=1,N
   80 Y2(J)=YEIG1(J)**2/Y2(J)
      CALL XMAXMI(Y2,AMAX,AMIN,N)
      AMAX=AMAX/5.0
      DO 90 J=1,N
      V(J)=1.0
      IF(IWEIGH.EQ.1.AND.Y2(J).LT.AMAX) V(J)=Y2(J)/AMAX
   90 CONTINUE
C IF THERE IS REWEIGHTING TO BE DONE THIS IS NOW ACCOMPLISHED BY
C MULTIPLYING BY V(J)
      DO 100 I=1,MI
      ID1=IBEGIN(I)
      ID2=IEND(I)
      DO 95 ID=ID1,ID2
      J=IDAT(ID)
   95 QIDAT(ID)=QIDAT(ID)*V(J)
  100 CONTINUE
      IF(IWEIGH.EQ.0) GOTO 110
      WRITE(IUOUT2,2012)
      WRITE(IUOUT2,2013) (V(J),J=1,N)
 2012 FORMAT(///1X,'WEIGHTS APPLIED')
 2013 FORMAT(1X,20F6.3)
  110 IF(IWEIGH.EQ.0) WRITE(IUOUT2,2014)
 2014 FORMAT(///1X,'NO DOWNWEIGHTING')
      IF(IRESC.EQ.0) WRITE(IUOUT2,2015)
 2015 FORMAT(/1X,'NO RESCALING'/)
      IF(IRESC.NE.0) WRITE(IUOUT2,2016)
 2016 FORMAT(/1X,'AXES ARE RESCALED'/)
      IF(IRA.EQ.1) WRITE(IUOUT2,2119)
 2119 FORMAT(1X,'RECIPROCAL AVERAGING'/)
      DO 170 I=1,MI
  170 XEIG1(I)=1.0
      CALL XYMULT(XEIG1,ADOTJ,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      TOT=0.0
      DO 180 J=1,N
      IF(ADOTJ(J).LT.1.0E-11) ADOTJ(J)=1.0E-11
      TOT=TOT+ADOTJ(J)
  180 CONTINUE
      DO 190 J=1,N
  190 YEIG1(J)=1.0
      CALL YXMULT(YEIG1,AIDOT,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
C PRELIMINARIES ARE NOW OVER.  EIGENVECTORS ARE CALCULATED.
      CALL EIGY(XEIG1,YEIG1,EIG1,0,IRA,IRESC,SHORT,
     1MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT,Y2,Y3,Y4,Y5,
     2XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,AIDOT,ADOTJ)
      IF(IRA.EQ.0) CALL CUTUP(XEIG1,IX1,MI,MK)
      CALL EIGY(XEIG2,YEIG2,EIG2,1,IRA,IRESC,SHORT,
     1MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT,Y2,Y3,Y4,Y5,
     2XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,AIDOT,ADOTJ)
      IF(IRA.EQ.0) CALL CUTUP(XEIG2,IX2,MI,MK)
      CALL EIGY(XEIG3,YEIG3,EIG3,2,IRA,IRESC,SHORT,
     1MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT,Y2,Y3,Y4,Y5,
     2XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,AIDOT,ADOTJ)
      IF(IRA.EQ.0) CALL CUTUP(XEIG3,IX3,MI,MK)
      CALL EIGY(XEIG4,YEIG4,EIG4,3,IRA,IRESC,SHORT,
     1MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT,Y2,Y3,Y4,Y5,
     2XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,AIDOT,ADOTJ)
      WRITE(IUOUT2,2100)
      CALL YXMULT(YEIG1,XEIG1,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      CALL YXMULT(YEIG2,XEIG2,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      CALL YXMULT(YEIG3,XEIG3,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      CALL YXMULT(YEIG4,XEIG4,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      DO 300 I=1,MI
      IX1(I)=IFIX(XEIG1(I)*100.0/AIDOT(I))
      IX2(I)=IFIX(XEIG2(I)*100.0/AIDOT(I))
      IX3(I)=IFIX(XEIG3(I)*100.0/AIDOT(I))
      IX4(I)=IFIX(XEIG4(I)*100.0/AIDOT(I))
  300 CONTINUE
      DO 310 J=1,N
      IY1(J)=IFIX(100.0*YEIG1(J))
      IY2(J)=IFIX(100.0*YEIG2(J))
      IY3(J)=IFIX(100.0*YEIG3(J))
      IY4(J)=IFIX(100.0*YEIG4(J))
  310 CONTINUE
C---FOLLOWING SECTION (TO STATEMENT 330) ADDED BY P.MINCHIN FEB 1988
      IF (IPUNCH.EQ.0) GO TO 350
      NMIN=MIN0(N,MI)
      NMAX=MAX0(N,MI)
      DO 330 I=1,NMAX
        IF (I.GT.MI) GO TO 315
          SCORES(1)=XEIG1(I)/AIDOT(I)
          SCORES(2)=XEIG2(I)/AIDOT(I)
          SCORES(3)=XEIG3(I)/AIDOT(I)
          SCORES(4)=XEIG4(I)/AIDOT(I)
  315   IF (I.GT.N) GO TO 320
          SCORES(5)=YEIG1(I)
          SCORES(6)=YEIG2(I)
          SCORES(7)=YEIG3(I)
          SCORES(8)=YEIG4(I)
  320   IF (I.LE.NMIN) WRITE (IUOUT3,1000) (SCORES(J),J=1,8)
 1000   FORMAT (8F10.4)
        IF (I.GT.MI) WRITE (IUOUT3,1001) (SCORES(J),J=5,8)
 1001   FORMAT (40X,4F10.4)
        IF (I.GT.N) WRITE (IUOUT3,1000) (SCORES(J),J=1,4)
  330 CONTINUE
C VECTORS IX*,IY* NOW CONTAIN THE SCORES.  REMAINDER OF PROGRAM
C PUTS THESE OUT IN APPROPRIATE FORM.
 2100 FORMAT('1')
C---STATEMENT LABEL 350 ADDED BY P.MINCHIN FEB 1988
  350 WRITE(IUOUT2,2200) (TITLE(IT),IT=1,19)
      MK=MK-4
      WRITE(IUOUT2,2201) IWEIGH,IRESC,IRA,MK,SHORT
 2200 FORMAT(1X,19A4)
 2201 FORMAT(1X,'DECORANA OPTIONS -- DOWNWEIGHTING',I2,'   RESCALING',
     1I3,'   ANALYSIS',I2,'   SEGMENTS',I3,'   THRESHOLD',F6.2)
 2203 FORMAT(1X,'DECORANA OPTIONS -- ',4I4,F6.2)
      IT=0
  270 IT=IT+1
      IF(BEFORE(IT).LT.9.9E9) GOTO 270
      ITEND=IT-1
      WRITE(IUOUT2, 2300) (BEFORE(IT),AFTER(IT),IT=2,ITEND)
 2300 FORMAT((1X,'TRANSFORMATION',5(6X,F8.2,F8.2)))
C---COMMENTED OUT BY P.MINCHIN FEB 1988
C      IF(IPUNCH.EQ.0) GOTO 400
C      WRITE(IUOUT3,2200) (TITLE(IT),IT=1,19)
C      WRITE(IUOUT3,2203) IWEIGH,IRESC,IRA,MK,SHORT
C      WRITE(IUOUT3,2301) (BEFORE(IT),AFTER(IT),IT=2,ITEND)
C 2301 FORMAT(1X,'TRANSFORMATION',10F6.2)
C      WRITE(IUOUT3,2101)
C  400 CONTINUE
      WRITE(IUOUT2,2101)
 2101 FORMAT(/1X,'SPECIES SCORES'/1X)
      JJ=0
      DO 450 J=1,N
      IF(ADOTJ(J).EQ.1.0E-11) GOTO 450
      JJ=JJ+1
      JNAME1(JJ)=JNAME1(J)
      JNAME2(JJ)=JNAME2(J)
      IY1(JJ)=IY1(J)
      IY2(JJ)=IY2(J)
      IY3(JJ)=IY3(J)
      IY4(JJ)=IY4(J)
      JNFLAG(JJ)=J
  450 CONTINUE
      N=JJ
      CALL EIGOUT(0,N,IY1,IYY1,IY2,IYY2,IY3,IYY3,
     1IY4,IYY4,JNAME1,JNAME2,JNFLAG,IPUNCH,EIG1,EIG2,EIG3,EIG4)
      WRITE(IUOUT2,2100)
      WRITE(IUOUT2,2200) (TITLE(IT),IT=1,19)
      WRITE(IUOUT2,2201) IWEIGH,IRESC,IRA,MK,SHORT
      WRITE(IUOUT2,2300) (BEFORE(IT),AFTER(IT),IT=2,ITEND)
C---COMMENTED OUT BY P.MINCHIN FEB 1988
C      IF(IPUNCH.EQ.0) GOTO 500
C      WRITE(IUOUT3,2220)
C 2220 FORMAT(///1X)
C      WRITE(IUOUT3,2200) (TITLE(IT),IT=1,19)
C      WRITE(IUOUT3,2203) IWEIGH,IRESC,IRA,MK,SHORT
C      WRITE(IUOUT3,2301) (BEFORE(IT),AFTER(IT),IT=2,ITEND)
C      WRITE(IUOUT3,2102)
C  500 CONTINUE
      WRITE(IUOUT2,2102)
 2102 FORMAT(/1X,'SAMPLE SCORES - WHICH ARE WEIGHTED MEAN SPECIES ',
     1'SCORES'/1X)
      CALL EIGOUT(1,MI,IX1,IXX1,IX2,IXX2,IX3,IXX3,
     1IX4,IXX4,INAME1,INAME2,INFLAG,IPUNCH,EIG1,EIG2,EIG3,EIG4)
      WRITE(IUOUT2,2100)
      CALL DIAGR(1,2,IX1,IX2,IXX1,IXX2,IXX3,MI,
     1IY1,IY2,IYY1,IYY2,IYY3,N)
      WRITE(IUOUT2,2150)
 2150 FORMAT(//1X)
      CALL DIAGR(1,3,IX1,IX3,IXX1,IXX2,IXX3,MI,
     1IY1,IY3,IYY1,IYY2,IYY3,N)
      WRITE(IUOUT2,2100)
      CALL DIAGR(1,4,IX1,IX4,IXX1,IXX2,IXX3,MI,
     1IY1,IY4,IYY1,IYY2,IYY3,N)
      WRITE(IUOUT2,2150)
      CALL DIAGR(2,3,IX2,IX3,IXX1,IXX2,IXX3,MI,
     1IY2,IY3,IYY1,IYY2,IYY3,N)
      STOP
      END
C---New Routines IARGC and GETARG added P.Minchin 1997 for getting
C---file names off the command line
C      INTEGER FUNCTION IARGC (CMLINE)
C
C Returns the number of tokens on the command line
C
C      CHARACTER*256 CMLINE
C      LOGICAL GOTONE
C      GOTONE=.FALSE.
C      N=0
C      DO 100 I=1,256
C        IF (CMLINE(I:I).NE.' ') THEN
C          IF (.NOT.GOTONE) THEN
C            GOTONE=.TRUE.
C            N=N+1
C          ENDIF
C        ELSE
C          IF (GOTONE) THEN
C            GOTONE=.FALSE.
C          ENDIF
C        ENDIF
C  100 CONTINUE
C      IARGC=N
C      RETURN
C      END
C      SUBROUTINE GETARG (N,CMLINE,ARG)
C
C Return the Nth token in CMLINE as ARG
C
C      CHARACTER CMLINE*256, ARG*80
C      LOGICAL GOTONE
C      GOTONE=.FALSE.
C      J=0
C      DO 100 I=1,256
C        IF (CMLINE(I:I).NE.' ') THEN
C          IF (.NOT.GOTONE) THEN
C            GOTONE=.TRUE.
C            J=J+1
C            IF (J.EQ.N) THEN
C              L=0
C              DO 50 K=I,256
C                IF (CMLINE(K:K).EQ.' ') RETURN
C                L=L+1
C                IF (L.GT.80) RETURN
C                ARG(L:L)=CMLINE(K:K)
C   50         CONTINUE
C              RETURN
C            ENDIF
C          ENDIF
C        ELSE
C          IF (GOTONE) THEN
C            GOTONE=.FALSE.
C          ENDIF
C        ENDIF
C  100 CONTINUE
C      ARG(1:1)=' '
C      RETURN
C      END
C
      SUBROUTINE CUTUP(X,IX,MI,MK)
C TAKES A VECTOR X AND CUTS UP INTO (MK-4) SEGMENTS, PUTTING A
C SEGMENTED VERSION OF THE VECTOR IN IX.
      REAL X(MI)
      INTEGER IX(MI)
      MMK=MK-4
      MAXK=MK-2
      CALL XMAXMI(X,AXMAX,AXMIN,MI)
      AXBIT=(AXMAX-AXMIN)/FLOAT(MMK)
      DO 10 I=1,MI
      IAX=IFIX((X(I)-AXMIN)/AXBIT)+3
      IF(IAX.LT.3) IAX=3
      IF(IAX.GT.MAXK) IAX=MAXK
   10 IX(I)=IAX
      RETURN
      END
C
      SUBROUTINE TRANS(Y,YY,
     1X,NEIG,IRA,AIDOT,XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,
     2MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT)
C THIS SUBROUTINE IS THE CRUX OF THE WHOLE PROGRAM, IN THAT IT
C TAKES A SET OF SPECIES SCORES Y AND ITERATES TO FIND A NEW SET
C OF SCORES YY.  REPEATED ITERATION OF THIS SUBROUTINE WOULD LEAD
C EVENTUALLY TO THE CORRECT SOLUTION (EXCEPT THAT THE SCORES NEED
C TO BE DIVIDED BY THE Y-TOTALS ADOTJ AT EACH ITERATION).  THE
C CALLING PROGRAM EIGY IS MADE LENGTHY BY SOME FANCY ALGEBRA PUT
C THERE TO SPEED UP THE CALCULATION.  ESSENTIALLY TRANS IS THE
C STANDARD RECIPROCAL AVERAGING ITERATION WITH EITHER DETRENDING
C WITH RESPECT TO PREVIOUSLY DERIVED AXES (IN THE CASE OF DETRENDED
C CORRESPONDENCE ANALYSIS) OR ORTHOGONALIZATION WITH RESPECT TO
C THEM (IN THE CASE OF RECIPROCAL AVERAGING).
      REAL X(MI),XEIG1(MI),XEIG2(MI),XEIG3(MI)
      REAL Y(N),YY(N),AIDOT(MI),QIDAT(NID)
      INTEGER IX1(MI),IX2(MI),IX3(MI),IDAT(NID),IBEGIN(MI),IEND(MI)
      CALL YXMULT(Y,X,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      DO 10 I=1,MI
   10 X(I)=X(I)/AIDOT(I)
      IF(NEIG.EQ.0) GOTO 200
      IF(IRA.EQ.1) GOTO 100
      CALL DETRND(X,AIDOT,IX1,MI,MK)
      IF(NEIG.EQ.1) GOTO 200
      CALL DETRND(X,AIDOT,IX2,MI,MK)
      IF(NEIG.EQ.2) GOTO 90
      CALL DETRND(X,AIDOT,IX3,MI,MK)
      CALL DETRND(X,AIDOT,IX2,MI,MK)
   90 CALL DETRND(X,AIDOT,IX1,MI,MK)
      GOTO 200
  100 A1=0.0
      DO 110 I=1,MI
  110 A1=A1+AIDOT(I)*X(I)*XEIG1(I)
      DO 120 I=1,MI
  120 X(I)=X(I)-A1*XEIG1(I)
      IF(NEIG.EQ.1) GOTO 200
      A2=0.0
      DO 130 I=1,MI
  130 A2=A2+AIDOT(I)*X(I)*XEIG2(I)
      DO 140 I=1,MI
  140 X(I)=X(I)-A2*XEIG2(I)
      IF(NEIG.EQ.2) GOTO 200
      A3=0.0
      DO 150 I=1,MI
  150 A3=A3+AIDOT(I)*X(I)*XEIG3(I)
      DO 160 I=1,MI
  160 X(I)=X(I)-A3*XEIG3(I)
  200 CALL XYMULT(X,YY,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      RETURN
      END
C
      SUBROUTINE DETRND(X,AIDOT,IX,MI,MK)
      REAL X(MI),Z(50),ZN(50),ZBAR(50),AIDOT(MI)
      INTEGER IX(MI)
C STARTS WITH A VECTOR X AND DETRENDS WITH RESPECT TO GROUPS DEFINED
C BY IX.  DETRENDING IS IN BLOCKS OF 3 UNITS AT A TIME, AND THE
C RESULT CALCULATED IS THE AVERAGE OF THE 3 POSSIBLE RESULTS THAT
C CAN BE OBTAINED, CORRESPONDING TO 3 POSSIBLE STARTING POSITIONS
C FOR THE BLOCKS OF 3.
      DO 10 K=1,MK
      Z(K)=0.0
   10 ZN(K)=0.0
      DO 20 I=1,MI
      K=IX(I)
      Z(K)=Z(K)+X(I)*AIDOT(I)
   20 ZN(K)=ZN(K)+AIDOT(I)
      MMK=MK-1
      DO 30 K=2,MMK
   30 ZBAR(K)=(Z(K-1)+Z(K)+Z(K+1))/(ZN(K-1)+ZN(K)+ZN(K+1)+1.0E-12)
      MMK=MMK-1
      DO 35 K=3,MMK
   35 Z(K)=(ZBAR(K-1)+ZBAR(K)+ZBAR(K+1))/3.0
      DO 40 I=1,MI
      K=IX(I)
   40 X(I)=X(I)-Z(K)
      RETURN
      END
C
      SUBROUTINE EIGY(X,Y,EIG,NEIG,IRA,IRESC,SHORT,
     1MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT,Y2,Y3,Y4,Y5,
     2XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,AIDOT,ADOTJ)
C EXTRACTS AN EIGENVECTOR Y WITH EIGENVALUE EIG.  THE ALGEBRA
C IS A LITTLE COMPLICATED, BUT CONSISTS ESSENTIALLY OF REPRE-
C SENTING THE TRANSFORMATION (SUBROUTINE TRANS) APPROXIMATELY
C BY A TRIDIAGONAL 4X4 MATRIX.  THE EIGENPROBLEM FOR THE
C TRIDIAGONAL MATRIX IS SOLVED AND THIS SOLUTION IS PLUGGED
C BACK IN TO OBTAIN A NEW TRIAL VECTOR.
C AFTER GETTING THE EIGENVECTOR, THE SCORES MAY BE RESCALED
C (SUBROUTINE STRTCH).
      REAL X(MI),Y(N),Y2(N),Y3(N),Y4(N),Y5(N)
      REAL XEIG1(MI),XEIG2(MI),XEIG3(MI),AIDOT(MI),ADOTJ(N)
      REAL QIDAT(NID)
      INTEGER IBEGIN(MI),IEND(MI),IDAT(NID),IX1(MI),IX2(MI),IX3(MI)
C---COMMON BLOCK ADDED BY P.MINCHIN FEB 1988
      COMMON /LUNITS/ IUINP1,IUINP2,IUOUT1,IUOUT2,IUOUT3
      TOT=0.0
      DO 10 J=1,N
      TOT=TOT+ADOTJ(J)
   10 Y(J)=FLOAT(J)
      Y(1)=1.1
C---Tolerance reduced by P.Minchin Jan 1997
C      TOL=0.0001
      TOL=0.000005
      CALL TRANS(Y,Y,
     1X,NEIG,IRA,AIDOT,XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,
     2MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      ICOUNT=0
   20 A=0.0
      DO 30 J=1,N
   30 A=A+Y(J)*ADOTJ(J)
      A=A/TOT
      EX=0.0
      DO 40 J=1,N
      AY=Y(J)-A
      EX=EX+AY*AY*ADOTJ(J)
   40 Y(J)=AY
      EX=SQRT(EX)
      DO 50 J=1,N
   50 Y(J)=Y(J)/EX
      CALL TRANS(Y,Y2,
     1X,NEIG,IRA,AIDOT,XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,
     2MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      A=0.0
      A11=0.0
      A12=0.0
      A22=0.0
      A23=0.0
      A33=0.0
      A34=0.0
      A44=0.0
      DO 60 J=1,N
      AY=Y2(J)
      Y2(J)=AY/ADOTJ(J)
      A=A+AY
   60 A11=A11+AY*Y(J)
      A=A/TOT
      DO 70 J=1,N
      AY=Y2(J)-(A+A11*Y(J))
      A12=A12+AY*AY*ADOTJ(J)
   70 Y2(J)=AY
      A12=SQRT(A12)
      DO 80 J=1,N
   80 Y2(J)=Y2(J)/A12
      IF(ICOUNT.EQ.0) WRITE(IUOUT2,1000)
 1000 FORMAT(/1X)
      WRITE(IUOUT1,1011) A12,ICOUNT
      WRITE(IUOUT2,1011) A12,ICOUNT
 1011 FORMAT(1X,'RESIDUAL',F10.6,'       AT ITERATION',I3)
      IF(A12.LT.TOL) GOTO 200
C---Maximum iteration limit increased by P.Minchin Jan 1997
C      IF(ICOUNT.GT.9) GOTO 200
      IF(ICOUNT.GT.999) GOTO 200
      ICOUNT=ICOUNT+1
      CALL TRANS(Y2,Y3,
     1X,NEIG,IRA,AIDOT,XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,
     2MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      A=0.0
      B13=0.0
      DO 90 J=1,N
      AY=Y3(J)
      Y3(J)=AY/ADOTJ(J)
      A=A+AY
      A22=A22+AY*Y2(J)
   90 B13=B13+AY*Y(J)
      A=A/TOT
      DO 100 J=1,N
      AY=Y3(J)-(A+A22*Y2(J)+B13*Y(J))
      A23=A23+AY*AY*ADOTJ(J)
  100 Y3(J)=AY
      A23=SQRT(A23)
      IF(A23.GT.TOL) GOTO 105
      A23=0.0
      GOTO 160
  105 CONTINUE
      DO 110 J=1,N
  110 Y3(J)=Y3(J)/A23
      CALL TRANS(Y3,Y4,
     1X,NEIG,IRA,AIDOT,XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,
     2MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      A=0.0
      B14=0.0
      B24=0.0
      DO 120 J=1,N
      AY=Y4(J)
      Y4(J)=Y4(J)/ADOTJ(J)
      A=A+AY
      A33=A33+AY*Y3(J)
      B14=B14+AY*Y(J)
  120 B24=B24+AY*Y2(J)
      A=A/TOT
      DO 130 J=1,N
      AY=Y4(J)-(A+A33*Y3(J)+B14*Y(J)+B24*Y2(J))
      A34=A34+AY*AY*ADOTJ(J)
  130 Y4(J)=AY
      A34=SQRT(A34)
      IF(A34.GT.TOL) GOTO 135
      A34=0.0
      GOTO 160
  135 CONTINUE
      DO 140 J=1,N
  140 Y4(J)=Y4(J)/A34
      CALL TRANS(Y4,Y5,
     1X,NEIG,IRA,AIDOT,XEIG1,XEIG2,XEIG3,IX1,IX2,IX3,
     2MI,MK,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      DO 150 J=1,N
  150 A44=A44+Y4(J)*Y5(J)
C WE NOW HAVE THE TRIDIAGONAL REPRESENTATION OF TRANS.  SOLVE
C EIGENPROBLEM FOR TRIDIAGONAL MATRIX.
  160 AX1=1.0
      AX2=0.1
      AX3=0.01
      AX4=0.001
      DO 170 ITIMES=1,100
      AXX1=A11*AX1+A12*AX2
      AXX2=A12*AX1+A22*AX2+A23*AX3
      AXX3=A23*AX2+A33*AX3+A34*AX4
      AXX4=A34*AX3+A44*AX4
      AX1=A11*AXX1+A12*AXX2
      AX2=A12*AXX1+A22*AXX2+A23*AXX3
      AX3=A23*AXX2+A33*AXX3+A34*AXX4
      AX4=A34*AXX3+A44*AXX4
      EX=SQRT(AX1**2+AX2**2+AX3**2+AX4**2)
      AX1=AX1/EX
      AX2=AX2/EX
      AX3=AX3/EX
      AX4=AX4/EX
      IF(ITIMES.NE.(ITIMES/5)*5) GOTO 170
      EXX=SQRT(EX)
      RESI=SQRT((AX1-AXX1/EXX)**2+(AX2-AXX2/EXX)**2+
     1(AX3-AXX3/EXX)**2+(AX4-AXX4/EXX)**2)
      IF(RESI.LT.TOL*0.05) GOTO 180
  170 CONTINUE
  180 CONTINUE
      DO 190 J=1,N
  190 Y(J)=AX1*Y(J)+AX2*Y2(J)+AX3*Y3(J)+AX4*Y4(J)
      GOTO 20
  200 WRITE(IUOUT2,1010) A11
      WRITE(IUOUT1,1010) A11
 1010 FORMAT(1X,'EIGENVALUE',F10.5)
      IF(A12.GT.TOL) WRITE(IUOUT2,1012) TOL
      IF(A12.GT.TOL) WRITE(IUOUT1,1012) TOL
 1012 FORMAT(1X,'*** BEWARE ***     RESIDUAL BIGGER THAN TOLERANCE',
     1', WHICH IS',F10.6)
C WE CALCULATE X FROM Y, AND SET X TO UNIT LENGTH IF RECIPROCAL
C AVERAGING OPTION IS IN FORCE (IRA=1)
      CALL XMAXMI(Y,AYMAX,AYMIN,N)
      SIGN=1.0
      IF(-AYMIN.GT.AYMAX) SIGN=-1.0
      DO 210 J=1,N
  210 Y(J)=Y(J)*SIGN
      CALL YXMULT(Y,X,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      DO 220 I=1,MI
  220 X(I)=X(I)/AIDOT(I)
      IF(IRESC.EQ.0) GOTO 225
      IF(A11.GT.0.999) GOTO 225
      DO 223 I=1,IRESC
      MONIT=0
      IF(I.EQ.1.OR.I.EQ.IRESC) MONIT=1
      CALL STRTCH(X,Y,SHORT,MONIT,
     1MI,N,NID,AIDOT,IBEGIN,IEND,IDAT,QIDAT)
  223 CONTINUE
      EIG=A11
      RETURN
  225 AXLONG=0.0
      DO 230 I=1,MI
  230 AXLONG=AXLONG+AIDOT(I)*X(I)**2
      AXLONG=SQRT(AXLONG)
      DO 240 I=1,MI
  240 X(I)=X(I)/AXLONG
      DO 250 J=1,N
  250 Y(J)=Y(J)/AXLONG
C IT REMAINS TO SCALE Y TO UNIT WITHIN-SAMPLE STANDARD DEVIATION
      SUMSQ=0.0
      DO 260 I=1,MI
      ID1=IBEGIN(I)
      ID2=IEND(I)
      AX=X(I)
      DO 255 ID=ID1,ID2
      J=IDAT(ID)
  255 SUMSQ=SUMSQ+QIDAT(ID)*(AX-Y(J))**2
  260 CONTINUE
      SD=SQRT(SUMSQ/TOT)
      IF(A11.LE.0.999) GOTO 265
      SD=AYMAX/AXLONG
      SD1=-AYMIN/AXLONG
      IF(SD1.GT.SD) SD=SD1
  265 CONTINUE
      DO 270 J=1,N
  270 Y(J)=Y(J)/SD
      EIG=A11
      RETURN
      END
C
      SUBROUTINE QUIKIN(MMAX,NMAX,NDAT,MM,N,INAME1,
     1INAME2,JNAME1,JNAME2,IDAT,QIDAT,IBEGIN,IEND,NID,TITLE,INFLAG)
C READS IN DATA MATRIX BY SAMPLES AND ROW AND COLUMN NAMES IN
C SPECIFIED FORMAT.  THE SAMPLES MUST BE IN ASCENDING NUMERICAL
C ORDER.  SECOND HALF OF SUBROUTINE CONSISTS OF AN OPTION TO DELETE
C UNWANTED SAMPLES FROM THE ANALYSIS.
C---Changed INAME & JNAME to CHARACTER variables: P.Minchin June 1997
      INTEGER IDAT(NDAT)
      CHARACTER*4 INAME1(MMAX),INAME2(MMAX),JNAME1(NMAX),
     1JNAME2(NMAX)
      INTEGER IBEGIN(MMAX),IEND(MMAX),INFLAG(MMAX)
      REAL QIDAT(NDAT)
C---FMT & TITLE changed CHARACTER variables: P.Minchin May 1997
C      REAL AITEM(100),FMT(15),TITLE(20)
      REAL AITEM(100)
      INTEGER ITEM(100)
      CHARACTER FMT*60, TITLE(20)*4
C---COMMON BLOCK ADDED BY P.MINCHIN FEB 1988
      COMMON /LUNITS/ IUINP1,IUINP2,IUOUT1,IUOUT2,IUOUT3
C---Logical unit number for input data file added: P.Minchin May 1997
      WRITE(IUOUT2,1002) IUINP2
      WRITE(IUOUT1,1002) IUINP2
C---Format modified for logical unit number: P.Minchin May 1997
 1002 FORMAT(///1X,'READING DATA MATRIX FROM DEVICE ',I2)
      READ(IUINP2,1000) (TITLE(IT),IT=1,20)
 1000 FORMAT(20A4)
      WRITE(IUOUT2,2000) (TITLE(IT),IT=1,20)
      WRITE(IUOUT1,2001) (TITLE(IT),IT=1,20)
 2000 FORMAT(//1X,20A4//)
 2001 FORMAT(//1X,19A4,A3//)
C---FMT read as a CHARACTER*60 variable: P.Minchin May 1997
C      READ(IUINP2,1001) (FMT(IT),IT=1,15),NITEM
C 1001 FORMAT(15A4,8X,I2)
      READ(IUINP2,1001) FMT,NITEM
 1001 FORMAT(A60,8X,I2)
C---Handling of "relaxed" CCF files: P.Minchin July 1997
      IF (NITEM.LE.0) READ (IUINP2,*) NITEM
      DO 10 II=1,MMAX
   10 INFLAG(II)=0
      ID=0
      N=0
      III=1
      ITEM(NITEM+1)=0
   40 READ(IUINP2,FMT) II,(ITEM(IT),AITEM(IT),IT=1,NITEM)
      IF(II.EQ.III) GOTO 50
      IEND(III)=ID
      IF(II.EQ.0) GOTO 100
      IBEGIN(II)=ID+1
      IF(II.LT.III) GOTO 999
      III=II
   50 IT=0
   55 IT=IT+1
      J=ITEM(IT)
      IF(J) 997,40,56
   56 IF(J.GT.N) N=J
      INFLAG(II)=1
      ID=ID+1
      IDAT(ID)=J
      AIJ=AITEM(IT)
      IF(AIJ.LT.0.0) GOTO 997
      QIDAT(ID)=AIJ
      IF(ID.GT.NDAT-3) GOTO 996
      GOTO 55
  100 MM=III
      IF(MM.GT.MMAX) GOTO 995
      IF(N.GT.NMAX) GOTO 994
      NID=ID
      IBEGIN(1)=1
C WE NOW READ THE SPECIES NAMES FOLLOWED BY THE SAMPLE NAMES
      READ(IUINP2,1100) (JNAME1(J),JNAME2(J),J=1,N)
      READ(IUINP2,1100) (INAME1(I),INAME2(I),I=1,MM)
 1100 FORMAT(20A4)
      WRITE(IUOUT1,2100)
      WRITE(IUOUT2,2100)
 2100 FORMAT(1X,'ENTER NUMBERS (NOT NAMES) OF SAMPLES TO BE ',
     1'OMITTED'/1X,'ONE AT A TIME, ENDING LIST WITH A ZERO'/)
  200 READ(IUINP1,*) NONO
      IF(NONO.LT.0) GOTO 200
      IF(NONO.GT.MMAX) GOTO 200
      IF(NONO.EQ.0) GOTO 300
      WRITE(IUOUT2,2101) NONO
      WRITE(IUOUT1,2101) NONO
 2101 FORMAT(1X,'SAMPLE',I6,'  TO BE OMITTED')
      INFLAG(NONO)=0
      GOTO 200
  300 WRITE(IUOUT2,2102) NONO
      WRITE(IUOUT1,2102) NONO
 2102 FORMAT(1X,6X,I6)
      I=0
      DO 400 II=1,MM
      IF(INFLAG(II).NE.1) GOTO 400
      I=I+1
      IBEGIN(I)=IBEGIN(II)
      IEND(I)=IEND(II)
      INAME1(I)=INAME1(II)
      INAME2(I)=INAME2(II)
      INFLAG(I)=II
  400 CONTINUE
      MM=I
      RETURN
  994 WRITE(IUOUT2,1994) N,NMAX
      WRITE(IUOUT1,1994) N,NMAX
 1994 FORMAT(1X,'***ABORT*** LARGEST SPECIES NUMBER ',
     1'IS',I4,'BUT SHOULD NOT EXCEED',I4)
      STOP
C---Bug fixed P.Minchin June 1997 - M changed to MM
  995 WRITE(IUOUT2,1995) MM,MMAX
      WRITE(IUOUT1,1995) MM,MMAX
 1995 FORMAT(1X,'***ABORT*** LARGEST SAMPLE NUMBER ',
     1'IS',I4,'BUT SHOULD NOT EXCEED',I4)
      STOP
  996 WRITE(IUOUT2,1996) II
      WRITE(IUOUT1,1996) II
 1996 FORMAT(1X,'***ABORT*** NO MORE SPACE FOR DATA ',
     1'MATRIX, STOPPED AT SAMPLE',I4)
      STOP
  997 WRITE(IUOUT2,1997) II
      WRITE(IUOUT1,1997) II
 1997 FORMAT(1X,'***ABORT*** NEGATIVE NUMBER FOUND IN SAMPLE',I4)
      STOP
  999 WRITE(IUOUT2,1999) III
      WRITE(IUOUT1,1999) III
 1999 FORMAT(1X,'***ABORT*** NON-SEQUENTIAL SAMPLE',
     1' NUMBER FOUND AFTER SAMPLE',I4)
      STOP
      END
C
      SUBROUTINE XYMULT(X,Y,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
C STARTS WITH VECTOR X AND FORMS MATRIX PRODUCT Y=AX
      REAL X(MI),Y(N),QIDAT(NID)
      INTEGER IBEGIN(MI),IEND(MI),IDAT(NID)
      DO 10 J=1,N
   10 Y(J)=0.0
      DO 30 I=1,MI
      ID1=IBEGIN(I)
      ID2=IEND(I)
      AX=X(I)
      DO 20 ID=ID1,ID2
      J=IDAT(ID)
   20 Y(J)=Y(J)+AX*QIDAT(ID)
   30 CONTINUE
      RETURN
      END
C
      SUBROUTINE YXMULT(Y,X,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
C STARTS WITH VECTOR Y AND FORMS MATRIX PRODUCT X=AY
      REAL X(MI),Y(N),QIDAT(NID)
      INTEGER IBEGIN(MI),IEND(MI),IDAT(NID)
      DO 20 I=1,MI
      ID1=IBEGIN(I)
      ID2=IEND(I)
      AX=0.0
      DO 10 ID=ID1,ID2
      J=IDAT(ID)
   10 AX=AX+Y(J)*QIDAT(ID)
   20 X(I)=AX
      RETURN
      END
C
      SUBROUTINE XMAXMI(X,AXMAX,AXMIN,M)
C FORMS MAXIMUM AND MINIMUM OF X(M)
      REAL X(M)
      AXMAX=-1.0E10
      AXMIN=-AXMAX
      DO 10 I=1,M
      AX=X(I)
      IF(AX.GT.AXMAX) AXMAX=AX
      IF(AX.LT.AXMIN) AXMIN=AX
   10 CONTINUE
      RETURN
      END
C
      SUBROUTINE EIGOUT(ISAMP,M,IX1,IXX1,IX2,IXX2,IX3,IXX3,
     1IX4,IXX4,INAME1,INAME2,INFLAG,IPUNCH,EIG1,EIG2,EIG3,EIG4)
C---Changed INAME & IOUT to CHARACTER: P.Minchin June 1997
C---Added references to new function I2CHAR to convert integer
C---values to text strings
      INTEGER IX1(M),IXX1(M),IX2(M),IXX2(M),IX3(M),IXX3(M),
     1IX4(M),IXX4(M),INFLAG(M)
      CHARACTER*4 INAME1(M), INAME2(M)
      CHARACTER*5 IOUT(23), I2CHAR
C PRINTS OUT EIGENVECTORS IN A TABLE.  IX* ARE THE VECTORS IN THE
C ORDINARY ORDER.  IXX* ARE RANKED IN ORDER OF DESCENDING SIZE.
C---COMMON BLOCK ADDED BY P.MINCHIN FEB 1988
      COMMON /LUNITS/ IUINP1,IUINP2,IUOUT1,IUOUT2,IUOUT3
      WRITE(IUOUT2,2000)
      WRITE(IUOUT2,2001) EIG1,EIG2,EIG3,EIG4
 2000 FORMAT(5X,'N',5X,'NAME    AX1  AX2  AX3  AX4',
     11X,']',7X,'RANKED 1',6X,']',7X,'RANKED 2',
     26X,']',7X,'RANKED 3',6X,']',7X,'RANKED 4',6X,']')
 2001 FORMAT(1X,37X,']',4(6X,'EIG=',F5.3,6X,']'))
      CALL ORDER (M,IX1,IXX1)
      CALL ORDER (M,IX2,IXX2)
      CALL ORDER (M,IX3,IXX3)
      CALL ORDER (M,IX4,IXX4)
      DO 300 I=1,M
      I1=IXX1(I)
      I2=IXX2(I)
      I3=IXX3(I)
      I4=IXX4(I)
C---Added references to I2CHAR to convert integers to character
C---strings P.Minchin June 1997
      IOUT(1)=I2CHAR(INFLAG(I))
      IOUT(2)=INAME1(I)
      IOUT(3)=INAME2(I)
      IOUT(4)=I2CHAR(IX1(I))
      IOUT(5)=I2CHAR(IX2(I))
      IOUT(6)=I2CHAR(IX3(I))
      IOUT(7)=I2CHAR(IX4(I))
      IOUT(8)=I2CHAR(INFLAG(I1))
      IOUT(9)=INAME1(I1)
      IOUT(10)=INAME2(I1)
      IOUT(11)=I2CHAR(IX1(I1))
      IOUT(12)=I2CHAR(INFLAG(I2))
      IOUT(13)=INAME1(I2)
      IOUT(14)=INAME2(I2)
      IOUT(15)=I2CHAR(IX2(I2))
      IOUT(16)=I2CHAR(INFLAG(I3))
      IOUT(17)=INAME1(I3)
      IOUT(18)=INAME2(I3)
      IOUT(19)=I2CHAR(IX3(I3))
      IOUT(20)=I2CHAR(INFLAG(I4))
      IOUT(21)=INAME1(I4)
      IOUT(22)=INAME2(I4)
      IOUT(23)=I2CHAR(IX4(I4))
      IF(ISAMP.EQ.0) GOTO 200
      WRITE(IUOUT2,2010) (IOUT(II),II=1,23)
C---COMMENTED OUT BY P.MINCHIN FEB 1988
C      IF(IPUNCH.EQ.1) WRITE(IUOUT3,2012) (IOUT(II),II=1,7)
C 2012 FORMAT(1X,I5,2X,2A4,1X,4I5)
C---Format altered P.Minchin June 1997
 2010 FORMAT(1X,A5,2X,2A4,1X,4A5,4(1X,']',A5,2X,2A4,A5),' ]')
      GOTO 300
  200 WRITE(IUOUT2,2011) (IOUT(II),II=1,23)
C---COMMENTED OUT BY P.MINCHIN FEB 1988
C      IF(IPUNCH.EQ.1) WRITE(IUOUT3,2013) (IOUT(II),II=1,7)
C 2013 FORMAT(1X,I5,2(1X,A4),1X,4I5)
C---Format altered P.Minchin June 1997
 2011 FORMAT(1X,A5,2(1X,A4),1X,4A5,4(1X,']',A5,2(1X,A4),A5),' ]')
  300 CONTINUE
      RETURN
      END
C---Function added P.Minchin June 1997
      CHARACTER*5 FUNCTION I2CHAR (I)
C---Converts an integer value to a CHARACTER string
      CHARACTER*5 TEMP
      WRITE (TEMP,1000) I
 1000 FORMAT (I5)
      I2CHAR=TEMP
      RETURN
      END
C
C
      SUBROUTINE ORDER(M,IX,IXX)
C TAKES A VECTOR IX AND DEFINES IXX SO THAT IXX(I)=INDEX OF THE ITH
C VALUE IN IX, RANKED FROM TOP DOWNWARDS. E.G. IF IX= 5 6 1 2 , THEN
C IXX= 2 1 4 3 , SO THAT IX(IXX(1))=6, THE LARGEST VALUE, ETC.
      INTEGER IX(M),IXX(M)
      DO 10 I=1,M
      IAX=IX(I)
      IABSX=IABS(IAX)
      IF(IABSX.LT.1000) GOTO 5
      IAX=(IAX/IABSX)*(1000+IABSX/10)
    5 IXX(I)=(2000-IAX)*2000+I
   10 CONTINUE
      CALL ISORT(IXX,M)
      DO 20 I=1,M
   20 IXX(I)=IXX(I)-(IXX(I)/2000)*2000
      RETURN
      END
C
      SUBROUTINE ISORT(IX,N)
      INTEGER IX(N)
C EFFICIENT (HEAP-SORT) IN SITU SORTING OF VECTOR IX(N)
      DO 10 I=1,N
      J=I
      JX=IX(J)
    5 IF(J.EQ.1) GOTO 8
      JJ=J/2
      JJX=IX(JJ)
      IF(JJX.GE.JX) GOTO 8
      IX(J)=JJX
      J=JJ
      GOTO 5
    8 IX(J)=JX
   10 CONTINUE
      I=N
      GOTO 14
   12 IX(J)=JX
   14 IF(I.EQ.1) RETURN
      JX=IX(I)
      IX(I)=IX(1)
      I=I-1
      J=1
      JJ=2
   15 IF(I-JJ) 12,17,16
   16 JJX=IX(JJ)
      JJJ=JJ+1
      JJJX=IX(JJJ)
      IF(JJX.GE.JJJX) GOTO 18
      IF(JX.GE.JJJX) GOTO 12
      IX(J)=JJJX
      J=JJJ
      JJ=J*2
      GOTO 15
   17 JJX=IX(JJ)
   18 IF(JX.GE.JJX) GOTO 12
      IX(J)=JJX
      J=JJ
      JJ=J*2
      GOTO 15
      END
C
      SUBROUTINE STRTCH(X,Y,SHORT,MONIT,
     1MI,N,NID,AIDOT,IBEGIN,IEND,IDAT,QIDAT)
C TAKES AN AXIS (X,Y) AND SCALES TO UNIT MEAN SQUARE DEV OF SPECIES
C SCORES PER SAMPLE.  AN ATTEMPT IS MADE FOR LONGER AXES (L > SHORT)
C TO SQUEEZE THEM IN AND OUT SO THAT THEY HAVE THE RIGHT MEAN SQUARE
C DEVIATION ALL THE WAY ALONG THE AXIS AND NOT ONLY ON AVERAGE.
      REAL X(MI),Y(N),AIDOT(MI),QIDAT(NID)
      REAL ZN(50),ZV(50)
      INTEGER IBEGIN(MI),IEND(MI),IDAT(NID)
C---COMMON BLOCK ADDED BY P.MINCHIN FEB 1988
      COMMON /LUNITS/ IUINP1,IUINP2,IUOUT1,IUOUT2,IUOUT3
      DO 200 ICOUNT=1,2
      MK=20
      CALL SEGMNT(X,Y,ZN,ZV,MI,MK,N,NID,
     1AIDOT,IBEGIN,IEND,IDAT,QIDAT)
      CALL SMOOTH(ZV,MK)
      CALL SMOOTH(ZN,MK)
      ZVSUM=0.0
      DO 50 K=1,MK
   50 ZVSUM=ZVSUM+ZV(K)/ZN(K)
      SD=SQRT(ZVSUM/FLOAT(MK))
C WE WANT MEAN WITHIN-SAMPLE SQUARE DEVIATION TO BE 1.0, SO WE DIVIDE
C EVERYTHING BY SD
      ALONG=0.0
      DO 60 I=1,MI
      AX=X(I)/SD
      X(I)=AX
   60 IF(ALONG.LT.AX) ALONG=AX
      IF(ICOUNT.EQ.1.AND.MONIT.EQ.1) WRITE(IUOUT2,1000)
 1000 FORMAT(/1X)
      IF(MONIT.EQ.1) WRITE(IUOUT2,1001) ALONG
 1001 FORMAT(1X,'LENGTH OF GRADIENT',F10.3)
      DO 70 J=1,N
   70 Y(J)=Y(J)/SD
      IF(ALONG.LT.SHORT) RETURN
      IF(ICOUNT.EQ.2) RETURN
      MK=IFIX(ALONG*5.0)+1
      IF(MK.LT.10) MK=10
      IF(MK.GT.45) MK=45
      CALL SEGMNT(X,Y,ZN,ZV,MI,MK,N,NID,AIDOT,IBEGIN,IEND,IDAT,QIDAT)
      CALL SMOOTH(ZV,MK)
      CALL SMOOTH(ZN,MK)
      ZVSUM=0.0
      DO 100 K=1,MK
      AZV=1.0/SQRT(0.2/ALONG+ZV(K)/ZN(K))
      ZVSUM=ZVSUM+AZV
  100 ZV(K)=AZV
      DO 110 K=1,MK
  110 ZV(K)=ZV(K)*ALONG/ZVSUM
      IF(MONIT.EQ.1) WRITE(IUOUT2,1002) (ZV(K),K=1,MK)
 1002 FORMAT(1X,'LENGTH OF SEGMENTS',10F6.2)
      AZ=0.0
      ZN(1)=0.0
      DO 120 K=1,MK
      AZ=AZ+ZV(K)
  120 ZN(K+1)=AZ
      AXBIT=ALONG/FLOAT(MK)
      DO 130 J=1,N
      IAY=IFIX(Y(J)/AXBIT)+1
      IF(IAY.LT.1) IAY=1
      IF(IAY.GT.MK) IAY=MK
  130 Y(J)=ZN(IAY)+ZV(IAY)*(Y(J)/AXBIT-FLOAT(IAY-1))
      CALL YXMULT(Y,X,MI,N,NID,IBEGIN,IEND,IDAT,QIDAT)
      DO 140 I=1,MI
  140 X(I)=X(I)/AIDOT(I)
  200 CONTINUE
      RETURN
      END
C
      SUBROUTINE SMOOTH(Z,MK)
      REAL Z(MK)
C TAKES A VECTOR Z AND DOES (1,2,1)-SMOOTHING UNTIL NO BLANKS LEFT
C AND THEN 2 MORE ITERATIONS OF (1,2,1)-SMOOTHING.  IF NO BLANKS TO
C BEGIN WITH, THEN DOES 3 SMOOTHINGS, I.E. EFFECTIVELY (1,6,15,20,
C 15,6,1)-SMOOTHING.
      ISTOP=1
      DO 20 ICOUNT=1,50
      AZ2=Z(1)
      AZ3=Z(2)
      IF(AZ3.EQ.0.0) ISTOP=0
      Z(1)=0.75*AZ2+0.25*AZ3
      DO 10 K3=3,MK
      AZ1=AZ2
      AZ2=AZ3
      AZ3=Z(K3)
C---Bug in next line fixed by P.Minchin Jan 1997
C      IF(AZ3.LT.0.0) ISTOP=0
      IF(AZ3.LE.0.0) ISTOP=0
   10 Z(K3-1)=0.5*(AZ2+0.5*(AZ1+AZ3))
      Z(MK)=0.25*AZ2+0.75*AZ3
      ISTOP=ISTOP+1
      IF(ISTOP.EQ.4) GOTO 30
   20 CONTINUE
   30 RETURN
      END
C
      SUBROUTINE SEGMNT(X,Y,ZN,ZV,MI,MK,N,NID,
     1AIDOT,IBEGIN,IEND,IDAT,QIDAT)
C GIVEN AN ORDINATION (X,Y), CALCULATES NUMBERS AND SUMMED MEAN-SQUARE
C DEVIATIONS IN MK SEGMENTS.  ZN(K) IS THE NUMBER OF SAMPLES IN SEGMENT
C K;  ZV(K) IS THE SUMMED MEAN-SQUARE DEVIATION.  (WE AIM TO MAKE ZV,
C ZN AS NEARLY EQUAL AS POSSIBLE.)
      REAL X(MI),Y(N),ZN(MK),ZV(MK),AIDOT(MI),QIDAT(NID)
      INTEGER IBEGIN(MI),IEND(MI),IDAT(NID)
      DO 10 K=1,MK
      ZN(K)=-1.0E-20
   10 ZV(K)=-1.0E-20
      CALL XMAXMI(X,AXMAX,AXMIN,MI)
      AXBIT=(AXMAX-AXMIN)/FLOAT(MK)
      DO 20 I=1,MI
   20 X(I)=X(I)-AXMIN
      DO 30 J=1,N
   30 Y(J)=Y(J)-AXMIN
      DO 50 I=1,MI
      SQCORR=0.0
      SUMSQ=2.0E-20
      ID1=IBEGIN(I)
      ID2=IEND(I)
      AX=X(I)
      DO 40 ID=ID1,ID2
      J=IDAT(ID)
      AIJ=QIDAT(ID)
      SQCORR=SQCORR+AIJ**2
   40 SUMSQ=SUMSQ+AIJ*(AX-Y(J))**2
      SQCORR=SQCORR/AIDOT(I)**2
      IF(SQCORR.GT.0.9999) SQCORR=0.9999
      SUMSQ=SUMSQ/AIDOT(I)
      K=IFIX(AX/AXBIT)+1
      IF(K.GT.MK) K=MK
      IF(K.LT.1) K=1
      ZV(K)=ZV(K)+SUMSQ
      ZN(K)=ZN(K)+1.0-SQCORR
   50 CONTINUE
      RETURN
      END
C
      SUBROUTINE DIAGR(I1,I2,IX1,IX2,IXX1,IXX2,IX,M,
     1IY1,IY2,IYY1,IYY2,IY,N)
C DRAWS A SCATTER DIAGRAM OF THE RELATIONS BETWEEN IX1,IX2 AND
C IY1,IY2.  THE OTHER VECTORS ARE WORKSPACE.
      INTEGER IX(M),IX1(M),IX2(M),IXX1(M),IXX2(M)
      INTEGER IY(N),IY1(N),IY2(N),IYY1(N),IYY2(N)
C---Changed to put all character data in CHARACTER variables
C---P. Minchin June 1997
C      INTEGER NUMB(10),ILINE(100),IOUT(50)
      INTEGER IOUT(50)
      CHARACTER*1 NUMB(10),ILINE(100)
      CHARACTER*1 IMINUS, IBLANK, ISTAR
C---COMMON BLOCK ADDED BY P.MINCHIN FEB 1988
      COMMON /LUNITS/ IUINP1,IUINP2,IUOUT1,IUOUT2,IUOUT3
      DATA IMINUS,IBLANK,ISTAR/'-',' ','*'/
      DATA NUMB/'0','1','2','3','4','5','6','7','8','9'/
      IADD=2000
      IUNIT=25
      CALL PREPAR(IY1,IY2,IYY1,IYY2,IY,N,MAXY1,MAXY2,MINY1,MINY2,
     1IADD,IUNIT)
      IF(IUNIT.EQ.-1) RETURN
      CALL PREPAR(IX1,IX2,IXX1,IXX2,IX,M,MAXX1,MAXX2,MINX1,MINX2,
     1IADD,IUNIT)
      WRITE(IUOUT2,1000) I1,I2
 1000 FORMAT(1X,'SCATTER DIAGRAM OF ORDINATION, AXES',2I6)
      WRITE(IUOUT2,1001)
 1001 FORMAT(/1X,4X,'SPECIES',46X,'SAMPLES')
      I=1
      J=1
      KK=MAXY2
  103 DO 105 K=1,42
  105 IOUT(K)=0
  110 IF(I.GT.M) GOTO 120
      IAX=IX(I)
      IF(IXX2(IAX).NE.KK) GOTO 120
      IAX1=IXX1(IAX)-MINX1+23
      IOUT(IAX1)=IOUT(IAX1)+1
      I=I+1
      IF(I.LE.M) GOTO 110
  120 IF(J.GT.N) GOTO 130
      IAY=IY(J)
      IF(IYY2(IAY).NE.KK) GOTO 130
      IAY1=IYY1(IAY)-MINY1+2
      IOUT(IAY1)=IOUT(IAY1)+1
      J=J+1
      IF(J.LE.N) GOTO 120
  130 ITOPX=MAXX1-MINX1+24
      DO 140 K=ITOPX,43
  140 IOUT(K)=-1000
      ITOPY=MAXY1-MINY1+3
      DO 150 K=ITOPY,22
  150 IOUT(K)=-1000
      IOUT(1)=((KK+100)*IUNIT)/100-IUNIT
      IF(((KK*IUNIT)/100)*100.NE.KK*IUNIT) IOUT(1)=-1000
      IOUT(22)=IOUT(1)
  170 DO 200 K=1,42
      KZ=IOUT(K)
      IF(KZ.NE.-1000) GOTO 180
      ILINE(K*2-1)=IBLANK
      ILINE(K*2)=IBLANK
      GOTO 200
  180 IF(KZ.GE.0) GOTO 190
      ILINE(K*2-1)=IMINUS
      KZ=-KZ
      ILINE(K*2)=NUMB(1+KZ-(KZ/10)*10)
      GOTO 200
  190 IF(KZ.GT.0) GOTO 193
      IF(K.EQ.1) GOTO 193
      IF(K.EQ.22) GOTO 193
      IF(KK.EQ.-1000)GOTO 193
      ILINE(K*2-1)=IBLANK
      ILINE(K*2)=IMINUS
      GOTO 200
  193 IF(KZ.GT.9) GOTO 195
      ILINE(K*2-1)=IBLANK
      ILINE(K*2)=NUMB(KZ+1)
      GOTO 200
  195 IF(KZ.GT.99) GOTO 198
      ILINE(K*2-1)=NUMB(KZ/10+1)
      ILINE(K*2)=NUMB(KZ-(KZ/10)*10+1)
      GOTO 200
  198 IF(KZ.GT.999) GOTO 199
      ILINE(K*2-1)=NUMB(1+KZ/100)
      ILINE(K*2)=ISTAR
      GOTO 200
  199 ILINE(K*2-1)=ISTAR
      ILINE(K*2)=ISTAR
  200 CONTINUE
      WRITE(IUOUT2,1100) (ILINE(K),K=1,84)
 1100 FORMAT(1X,2A1,1X,40A1,10X,2A1,1X,40A1)
      IF(KK.EQ.-1000) RETURN
      KK=KK-1
      IF(KK.GE.MINY2) GOTO 103
      WRITE(IUOUT2,1101)
 1101 FORMAT(1X)
      DO 300 K=1,42
  300 IOUT(K)=-1000
      K1=2
      K2=MAXY1-MINY1+2
      DO 310 K=K1,K2
      KY=MINY1+K-2
      IF(KY.NE.(KY/2)*2) GOTO 310
      IF(IUNIT.NE.25) GOTO 305
      IF(KY.NE.(KY/4)*4) GOTO 310
  305 CONTINUE
      IOUT(K)=((KY+100)*IUNIT)/100-IUNIT
  310 CONTINUE
      K1=23
      K2=MAXX1-MINX1+23
      DO 320 K=K1,K2
      KX=MINX1+K-23
      IF(KX.NE.(KX/2)*2) GOTO 320
      IF(IUNIT.NE.25) GOTO 315
      IF(KX.NE.(KX/4)*4) GOTO 320
  315 CONTINUE
      IOUT(K)=((KX+100)*IUNIT)/100-IUNIT
  320 CONTINUE
      KK=-1000
      GOTO 170
      END
C
      SUBROUTINE PREPAR(IX1,IX2,IXX1,IXX2,IX,M,MAX1,MAX2,MIN1,MIN2,
     1IADD,IUNIT)
C GETS IX1,IX2 READY FOR PRINTING OUT AS A TABLE.  AN APPROPRIATE
C ORDER IN WHICH TO TAKE THE ITEMS IS STORED IN IX.  RESCALED
C VALUES ARE STORED IN IXX1,IXX2.
      INTEGER IX1(M),IX2(M),IXX1(M),IXX2(M),IX(M)
C---COMMON BLOCK ADDED BY P.MINCHIN FEB 1988
      COMMON /LUNITS/ IUINP1,IUINP2,IUOUT1,IUOUT2,IUOUT3
      IBIG=1000000
      ISMALL=-IBIG
    5 MAX1=ISMALL
      MAX2=ISMALL
      MIN1=IBIG
      MIN2=IBIG
      DO 10 I=1,M
      IAX1=(IX1(I)+IADD)/IUNIT-IADD/IUNIT
      IAX2=(IX2(I)+IADD)/IUNIT-IADD/IUNIT
      IF(IAX1.GT.MAX1) MAX1=IAX1
      IF(IAX2.GT.MAX2) MAX2=IAX2
      IF(IAX1.LT.MIN1) MIN1=IAX1
      IF(IAX2.LT.MIN2) MIN2=IAX2
      IXX1(I)=IAX1
      IXX2(I)=IAX2
   10 CONTINUE
      LONG1=MAX1-MIN1+1
      LONG2=MAX2-MIN2+1
      LENGTH=LONG1
      IF(LONG2.GT.LONG1) LENGTH=LONG2
      IF(LENGTH.LE.20) GOTO 30
      IUNIT=IUNIT*2
      IF(IUNIT.GT.200) GOTO 999
      GOTO 5
   30 DO 40 I=1,M
   40 IX(I)=(IADD-IXX2(I))*2000+I
      CALL ISORT(IX,M)
      DO 50 I=1,M
   50 IX(I)=IX(I)-(IX(I)/2000)*2000
      RETURN
  999 WRITE(IUOUT2,1999)
 1999 FORMAT(1X,'ORDINATION TOO LONG TO PRINT')
      IUNIT=-1
      RETURN
      END

